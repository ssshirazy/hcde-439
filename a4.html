<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, maximum-scale=1.0" />

    <title>Samira's HCDE 439 Physical Computing Page!</title>

    <link href="style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <h1>Samira's Assignment 4!</h1>
    <div class="header">
      <img src="images/a4-gif.gif" />
      <p>A GIF that displays my circuit</p>   
    </div>
    <img src="images/a4-circuit.jpg"/>
    <p>Photo of my circuit</p>
    <h4>Question 1</h4>
    <img src="images/a4-q1.jpeg"/>
    <p>Graph of question 1.</p>
    <h4>2: Your input device is slightly broken, leading it to give us an erroneous reading 1% of the time.
        How can we address this? Answer in (pseudo)code.</h4>
    <img src="images/a4-q2.jpg"/>
    <p>To address this erroneous reading, I would first start by establishing proper minimum and maximum bounds during calibration. 
        Then, during the reading phase, I would make sure that the values being measured are within the minimum and maximum that I calibrated.
        If it falls outside of that (less than the minimum or greater than the maximum), I would print out a message to let the user know that
        the value read was erroneous.
    </p>
    <h4>3: Your input device is slightly noisy, leading the measurement to randomly deviate from the true measurement up or down by 10%.
        How can we address this? Answer in (pseudo)code.</h4>
    <img src="images/a4-q3.jpeg"/>
    <p> To adjust the measurement based on a 10% deviation, first, I would compare the reading to the expected value.
        If the measurement is higher than expected, I would reduce it by 10% (multiply by 0.9).
        If it's lower than expected, I would increase it by 10% (multiply by 1.1).
        If the measurement is exactly equal to the expected value, no change is made.
        This makes sure that the measurement is adjusted depending on whether it is above or below the expected value.
    </p>
    <h4>Calculations Justification</h4>
    <p>I used a 1M Ohm Resistor. This is because the capacitor is measuring human resistance,
        which can range between 10,000-1,000,000, depending on different factors.
        I chose 1M Ohm specifically because it falls within the range of resistance the human body typically has, 
        creating a reference to measure the change in capacitance when someone touches the sensor.
    </p>
    <h4>Schematic</h4>
    <img src="images/a4-schematic.jpeg"/>
    <p>A schematic drawing of my circuit, including the capacitor and servo motor.</p>
    <h4>My Code</h4>
    <pre><code>
        // constant numbers (will not change)
        const int green = 13; // the number of the green LED pin
        const int blue = 10; // the number of the blue LED pin
        const int red = 11; // the number of the red LED pin
        
        int sensorMin = 1023; // minimum sensor value
        int sensorMax = 0; // maximum sensor value
        
        int x = A0; // pin number assoicated with the photoresistor   
        int sensVal = 0; // value read by photoresistor
        
        void setup() { // initializes the LED pins for output, runs once when board is powered/reset
          Serial.begin(9600); // allows the values read by the sensor to be printed in the serial monitor
          pinMode(green, OUTPUT); // initializes pin 13 as an output for a green LED
          pinMode(blue, OUTPUT); // initializes pin 10 as an output for a blue LED
          pinMode(red, OUTPUT); // initializes pin 11 as an output for a red LED
        
          while (millis() < 7000) { // calibration will occur during the first 7 seconds
            sensVal = analogRead(x); // the value read from the photoresistor
            Serial.println("Calibration period. The value being read is: " + String(sensVal) + "."); // prints the reading to the serial monitor
        
            if (sensVal > sensorMax) { // updates if a new maximum value is read
              sensorMax = sensVal; // sets the max equal to the new value read
            }
        
            if (sensVal < sensorMin) { // updates if a new minimum value is read
              sensorMin = sensVal; // sets the min equal to the new value read
            }
          
          
          digitalWrite(green, HIGH); // powers green LED, voltage is set to HIGH (5V). A visual indicator that informs the user when calibration is done
          delay(500); // delays for half of a second 
          digitalWrite(green, LOW); // turns off green LED, voltage set to LOW (0V)
          }
        }
        
        void loop() { // code repeated until power is no longer supplied or board is reset
          digitalWrite(green, HIGH); // powers green LED, voltage is set to HIGH (5V)
          digitalWrite(red, HIGH); // powers red LED, voltage is set to HIGH (5V)
        
          sensVal = analogRead(x); // the value read from the photoresistor
          sensVal = constrain(sensVal, sensorMin, sensorMax); // constrains the sensor reading to be between the minimum and maximum values read from calibration
        
          sensVal = map(sensVal, sensorMin, sensorMax, 0, 255); // maps the minimum sensor value read from calibration to 0 and the maximum value read to 255
        
          analogWrite(blue, sensVal); // set the brightness of blue LED based on the sensor value (sensVal)
        }                
    </code></pre>
    <h4>Acknowledgements</h4>
    For my code, I used the Arduino calibration example to help me set up my calibration. I referenced lesson slides A1-A5
    to help with creating my schematics and answering the questions.     
  </body>
</html>